import{d as yt,e as mt,o as rn,t as j,c as we,i as pe,F as wt,u as rt,S as ot,f as on,g as sn}from"./index-QHdL-lmg.js";import{a as an,c as cn,G as fn}from"./index-DhyUAv2L.js";const ln={},un=Object.freeze(Object.defineProperty({__proto__:null,default:ln},Symbol.toStringTag,{value:"Module"}));/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */const k=BigInt(0),R=BigInt(1),ce=BigInt(2),_e=BigInt(3),pt=BigInt(8),_=Object.freeze({a:k,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:R,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")}),bt=(t,e)=>(t+e/ce)/e,ze={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar(t){const{n:e}=_,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-R*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=n,c=BigInt("0x100000000000000000000000000000000"),f=bt(s*t,e),u=bt(-r*t,e);let h=d(t-f*n-u*o,e),w=d(-f*r-u*s,e);const a=h>c,l=w>c;if(a&&(h=e-h),l&&(w=e-w),h>c||w>c)throw new Error("splitScalarEndo: Endomorphism failed, k="+t);return{k1neg:a,k1:h,k2neg:l,k2:w}}},ve=32,Re=32,Et=ve+1,St=2*ve+1;function vt(t){const{a:e,b:n}=_,r=d(t*t),o=d(r*t);return d(o+e*t+n)}const Ne=_.a===k;class Ot extends Error{constructor(e){super(e)}}function xt(t){if(!(t instanceof A))throw new TypeError("JacobianPoint expected")}class A{constructor(e,n,r){this.x=e,this.y=n,this.z=r}static fromAffine(e){if(!(e instanceof $))throw new TypeError("JacobianPoint#fromAffine: expected Point");return e.equals($.ZERO)?A.ZERO:new A(e.x,e.y,R)}static toAffineBatch(e){const n=mn(e.map(r=>r.z));return e.map((r,o)=>r.toAffine(n[o]))}static normalizeZ(e){return A.toAffineBatch(e).map(A.fromAffine)}equals(e){xt(e);const{x:n,y:r,z:o}=this,{x:s,y:c,z:f}=e,u=d(o*o),h=d(f*f),w=d(n*h),a=d(s*u),l=d(d(r*f)*h),p=d(d(c*o)*u);return w===a&&l===p}negate(){return new A(this.x,d(-this.y),this.z)}double(){const{x:e,y:n,z:r}=this,o=d(e*e),s=d(n*n),c=d(s*s),f=e+s,u=d(ce*(d(f*f)-o-c)),h=d(_e*o),w=d(h*h),a=d(w-ce*u),l=d(h*(u-a)-pt*c),p=d(ce*n*r);return new A(a,l,p)}add(e){xt(e);const{x:n,y:r,z:o}=this,{x:s,y:c,z:f}=e;if(s===k||c===k)return this;if(n===k||r===k)return e;const u=d(o*o),h=d(f*f),w=d(n*h),a=d(s*u),l=d(d(r*f)*h),p=d(d(c*o)*u),T=d(a-w),C=d(p-l);if(T===k)return C===k?this.double():A.ZERO;const z=d(T*T),F=d(T*z),Z=d(w*z),q=d(C*C-F-ce*Z),m=d(C*(Z-q)-l*F),b=d(o*f*T);return new A(q,m,b)}subtract(e){return this.add(e.negate())}multiplyUnsafe(e){const n=A.ZERO;if(typeof e=="bigint"&&e===k)return n;let r=Bt(e);if(r===R)return this;if(!Ne){let a=n,l=this;for(;r>k;)r&R&&(a=a.add(l)),l=l.double(),r>>=R;return a}let{k1neg:o,k1:s,k2neg:c,k2:f}=ze.splitScalar(r),u=n,h=n,w=this;for(;s>k||f>k;)s&R&&(u=u.add(w)),f&R&&(h=h.add(w)),w=w.double(),s>>=R,f>>=R;return o&&(u=u.negate()),c&&(h=h.negate()),h=new A(d(h.x*ze.beta),h.y,h.z),u.add(h)}precomputeWindow(e){const n=Ne?128/e+1:256/e+1,r=[];let o=this,s=o;for(let c=0;c<n;c++){s=o,r.push(s);for(let f=1;f<2**(e-1);f++)s=s.add(o),r.push(s);o=s.double()}return r}wNAF(e,n){!n&&this.equals(A.BASE)&&(n=$.BASE);const r=n&&n._WINDOW_SIZE||1;if(256%r)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let o=n&&it.get(n);o||(o=this.precomputeWindow(r),n&&r!==1&&(o=A.normalizeZ(o),it.set(n,o)));let s=A.ZERO,c=A.BASE;const f=1+(Ne?128/r:256/r),u=2**(r-1),h=BigInt(2**r-1),w=2**r,a=BigInt(r);for(let l=0;l<f;l++){const p=l*u;let T=Number(e&h);e>>=a,T>u&&(T-=w,e+=R);const C=p,z=p+Math.abs(T)-1,F=l%2!==0,Z=T<0;T===0?c=c.add(Ze(F,o[C])):s=s.add(Ze(Z,o[z]))}return{p:s,f:c}}multiply(e,n){let r=Bt(e),o,s;if(Ne){const{k1neg:c,k1:f,k2neg:u,k2:h}=ze.splitScalar(r);let{p:w,f:a}=this.wNAF(f,n),{p:l,f:p}=this.wNAF(h,n);w=Ze(c,w),l=Ze(u,l),l=new A(d(l.x*ze.beta),l.y,l.z),o=w.add(l),s=a.add(p)}else{const{p:c,f}=this.wNAF(r,n);o=c,s=f}return A.normalizeZ([o,s])[0]}toAffine(e){const{x:n,y:r,z:o}=this,s=this.equals(A.ZERO);e==null&&(e=s?pt:tt(o));const c=e,f=d(c*c),u=d(f*c),h=d(n*f),w=d(r*u),a=d(o*c);if(s)return $.ZERO;if(a!==R)throw new Error("invZ was invalid");return new $(h,w)}}A.BASE=new A(_.Gx,_.Gy,R);A.ZERO=new A(k,R,k);function Ze(t,e){const n=e.negate();return t?n:e}const it=new WeakMap;class ${constructor(e,n){this.x=e,this.y=n}_setWindowSize(e){this._WINDOW_SIZE=e,it.delete(this)}hasEvenY(){return this.y%ce===k}static fromCompressedHex(e){const n=e.length===32,r=X(n?e:e.subarray(1));if(!Ke(r))throw new Error("Point is not on curve");const o=vt(r);let s=yn(o);const c=(s&R)===R;n?c&&(s=d(-s)):(e[0]&1)===1!==c&&(s=d(-s));const f=new $(r,s);return f.assertValidity(),f}static fromUncompressedHex(e){const n=X(e.subarray(1,ve+1)),r=X(e.subarray(ve+1,ve*2+1)),o=new $(n,r);return o.assertValidity(),o}static fromHex(e){const n=me(e),r=n.length,o=n[0];if(r===ve)return this.fromCompressedHex(n);if(r===Et&&(o===2||o===3))return this.fromCompressedHex(n);if(r===St&&o===4)return this.fromUncompressedHex(n);throw new Error(`Point.fromHex: received invalid point. Expected 32-${Et} compressed bytes or ${St} uncompressed bytes, not ${r}`)}static fromPrivateKey(e){return $.BASE.multiply(De(e))}static fromSignature(e,n,r){const{r:o,s}=En(n);if(![0,1,2,3].includes(r))throw new Error("Cannot recover: invalid recovery bit");const c=pn(me(e)),{n:f}=_,u=r===2||r===3?o+f:o,h=tt(u,f),w=d(-c*h,f),a=d(s*h,f),l=r&1?"03":"02",p=$.fromHex(l+fe(u)),T=$.BASE.multiplyAndAddUnsafe(p,w,a);if(!T)throw new Error("Cannot recover signature: point at infinify");return T.assertValidity(),T}toRawBytes(e=!1){return ie(this.toHex(e))}toHex(e=!1){const n=fe(this.x);return e?`${this.hasEvenY()?"02":"03"}${n}`:`04${n}${fe(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const e="Point is not on elliptic curve",{x:n,y:r}=this;if(!Ke(n)||!Ke(r))throw new Error(e);const o=d(r*r),s=vt(n);if(d(o-s)!==k)throw new Error(e)}equals(e){return this.x===e.x&&this.y===e.y}negate(){return new $(this.x,d(-this.y))}double(){return A.fromAffine(this).double().toAffine()}add(e){return A.fromAffine(this).add(A.fromAffine(e)).toAffine()}subtract(e){return this.add(e.negate())}multiply(e){return A.fromAffine(this).multiply(e,this).toAffine()}multiplyAndAddUnsafe(e,n,r){const o=A.fromAffine(this),s=n===k||n===R||this!==$.BASE?o.multiplyUnsafe(n):o.multiply(n),c=A.fromAffine(e).multiplyUnsafe(r),f=s.add(c);return f.equals(A.ZERO)?void 0:f.toAffine()}}$.BASE=new $(_.Gx,_.Gy);$.ZERO=new $(k,k);function At(t){return Number.parseInt(t[0],16)>=8?"00"+t:t}function kt(t){if(t.length<2||t[0]!==2)throw new Error(`Invalid signature integer tag: ${Ae(t)}`);const e=t[1],n=t.subarray(2,e+2);if(!e||n.length!==e)throw new Error("Invalid signature integer: wrong length");if(n[0]===0&&n[1]<=127)throw new Error("Invalid signature integer: trailing length");return{data:X(n),left:t.subarray(e+2)}}function dn(t){if(t.length<2||t[0]!=48)throw new Error(`Invalid signature tag: ${Ae(t)}`);if(t[1]!==t.length-2)throw new Error("Invalid signature: incorrect length");const{data:e,left:n}=kt(t.subarray(2)),{data:r,left:o}=kt(n);if(o.length)throw new Error(`Invalid signature: left bytes after parsing: ${Ae(o)}`);return{r:e,s:r}}class ge{constructor(e,n){this.r=e,this.s=n,this.assertValidity()}static fromCompact(e){const n=Ce(e),r="Signature.fromCompact";if(typeof e!="string"&&!n)throw new TypeError(`${r}: Expected string or Uint8Array`);const o=n?Ae(e):e;if(o.length!==128)throw new Error(`${r}: Expected 64-byte hex`);return new ge(Je(o.slice(0,64)),Je(o.slice(64,128)))}static fromDER(e){const n=Ce(e);if(typeof e!="string"&&!n)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");const{r,s:o}=dn(n?e:ie(e));return new ge(r,o)}static fromHex(e){return this.fromDER(e)}assertValidity(){const{r:e,s:n}=this;if(!Ue(e))throw new Error("Invalid Signature: r must be 0 < r < n");if(!Ue(n))throw new Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){const e=_.n>>R;return this.s>e}normalizeS(){return this.hasHighS()?new ge(this.r,d(-this.s,_.n)):this}toDERRawBytes(){return ie(this.toDERHex())}toDERHex(){const e=At(Be(this.s)),n=At(Be(this.r)),r=e.length/2,o=n.length/2,s=Be(r),c=Be(o);return`30${Be(o+r+4)}02${c}${n}02${s}${e}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return ie(this.toCompactHex())}toCompactHex(){return fe(this.r)+fe(this.s)}}function Ce(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function zt(t){if(!Ce(t))throw new Error("Uint8Array expected")}function Te(...t){if(t.every(zt),t.length===1)return t[0];const e=t.reduce((r,o)=>r+o.length,0),n=new Uint8Array(e);for(let r=0,o=0;r<t.length;r++){const s=t[r];n.set(s,o),o+=s.length}return n}const hn=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function Ae(t){zt(t);let e="";for(let n=0;n<t.length;n++)e+=hn[t[n]];return e}const re={_0:48,_9:57,A:65,F:70,a:97,f:102};function Tt(t){if(t>=re._0&&t<=re._9)return t-re._0;if(t>=re.A&&t<=re.F)return t-(re.A-10);if(t>=re.a&&t<=re.f)return t-(re.a-10)}function ie(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const e=t.length,n=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let o=0,s=0;o<n;o++,s+=2){const c=Tt(t.charCodeAt(s)),f=Tt(t.charCodeAt(s+1));if(c===void 0||f===void 0){const u=t[s]+t[s+1];throw new Error('hex string expected, got non-hex character "'+u+'" at index '+s)}r[o]=c*16+f}return r}const gn=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function fe(t){if(typeof t!="bigint")throw new Error("Expected bigint");if(!(k<=t&&t<gn))throw new Error("Expected number 0 <= n < 2^256");return t.toString(16).padStart(64,"0")}function He(t){const e=ie(fe(t));if(e.length!==32)throw new Error("Error: expected 32 bytes");return e}function Be(t){const e=t.toString(16);return e.length&1?`0${e}`:e}function Je(t){if(typeof t!="string")throw new TypeError("hexToNumber: expected string, got "+typeof t);return BigInt(`0x${t}`)}function X(t){return Je(Ae(t))}function me(t){return Ce(t)?Uint8Array.from(t):ie(t)}function Bt(t){if(typeof t=="number"&&Number.isSafeInteger(t)&&t>0)return BigInt(t);if(typeof t=="bigint"&&Ue(t))return t;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function d(t,e=_.P){const n=t%e;return n>=k?n:e+n}function W(t,e){const{P:n}=_;let r=t;for(;e-- >k;)r*=r,r%=n;return r}function yn(t){const{P:e}=_,n=BigInt(6),r=BigInt(11),o=BigInt(22),s=BigInt(23),c=BigInt(44),f=BigInt(88),u=t*t*t%e,h=u*u*t%e,w=W(h,_e)*h%e,a=W(w,_e)*h%e,l=W(a,ce)*u%e,p=W(l,r)*l%e,T=W(p,o)*p%e,C=W(T,c)*T%e,z=W(C,f)*C%e,F=W(z,c)*T%e,Z=W(F,_e)*h%e,q=W(Z,s)*p%e,m=W(q,n)*u%e,b=W(m,ce);if(b*b%e!==t)throw new Error("Cannot find square root");return b}function tt(t,e=_.P){if(t===k||e<=k)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=d(t,e),r=e,o=k,s=R;for(;n!==k;){const f=r/n,u=r%n,h=o-s*f;r=n,n=u,o=s,s=h}if(r!==R)throw new Error("invert: does not exist");return d(o,e)}function mn(t,e=_.P){const n=new Array(t.length),r=t.reduce((s,c,f)=>c===k?s:(n[f]=s,d(s*c,e)),R),o=tt(r,e);return t.reduceRight((s,c,f)=>c===k?s:(n[f]=d(s*n[f],e),d(s*c,e)),o),n}function wn(t){const e=t.length*8-Re*8,n=X(t);return e>0?n>>BigInt(e):n}function pn(t,e=!1){const n=wn(t);if(e)return n;const{n:r}=_;return n>=r?n-r:n}let xe,st;function Ue(t){return k<t&&t<_.n}function Ke(t){return k<t&&t<_.P}function De(t){let e;if(typeof t=="bigint")e=t;else if(typeof t=="number"&&Number.isSafeInteger(t)&&t>0)e=BigInt(t);else if(typeof t=="string"){if(t.length!==2*Re)throw new Error("Expected 32 bytes of private key");e=Je(t)}else if(Ce(t)){if(t.length!==Re)throw new Error("Expected 32 bytes of private key");e=X(t)}else throw new TypeError("Expected valid private key");if(!Ue(e))throw new Error("Expected private key: 0 < key < n");return e}function bn(t){return t instanceof $?(t.assertValidity(),t):$.fromHex(t)}function En(t){if(t instanceof ge)return t.assertValidity(),t;try{return ge.fromDER(t)}catch{return ge.fromCompact(t)}}function Qe(t){return d(X(t),_.n)}class ke{constructor(e,n){this.r=e,this.s=n,this.assertValidity()}static fromHex(e){const n=me(e);if(n.length!==64)throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${n.length}`);const r=X(n.subarray(0,32)),o=X(n.subarray(32,64));return new ke(r,o)}assertValidity(){const{r:e,s:n}=this;if(!Ke(e)||!Ue(n))throw new Error("Invalid signature")}toHex(){return fe(this.r)+fe(this.s)}toRawBytes(){return ie(this.toHex())}}function Sn(t){return $.fromPrivateKey(t).toRawX()}class Nt{constructor(e,n,r=Y.randomBytes()){if(e==null)throw new TypeError(`sign: Expected valid message, not "${e}"`);this.m=me(e);const{x:o,scalar:s}=this.getScalar(De(n));if(this.px=o,this.d=s,this.rand=me(r),this.rand.length!==32)throw new TypeError("sign: Expected 32 bytes of aux randomness")}getScalar(e){const n=$.fromPrivateKey(e),r=n.hasEvenY()?e:_.n-e;return{point:n,scalar:r,x:n.toRawX()}}initNonce(e,n){return He(e^X(n))}finalizeNonce(e){const n=d(X(e),_.n);if(n===k)throw new Error("sign: Creation of signature failed. k is zero");const{point:r,x:o,scalar:s}=this.getScalar(n);return{R:r,rx:o,k:s}}finalizeSig(e,n,r,o){return new ke(e.x,d(n+r*o,_.n)).toRawBytes()}error(){throw new Error("sign: Invalid signature produced")}async calc(){const{m:e,d:n,px:r,rand:o}=this,s=Y.taggedHash,c=this.initNonce(n,await s(ae.aux,o)),{R:f,rx:u,k:h}=this.finalizeNonce(await s(ae.nonce,c,r,e)),w=Qe(await s(ae.challenge,u,r,e)),a=this.finalizeSig(f,h,w,n);return await Vt(a,e,r)||this.error(),a}calcSync(){const{m:e,d:n,px:r,rand:o}=this,s=Y.taggedHashSync,c=this.initNonce(n,s(ae.aux,o)),{R:f,rx:u,k:h}=this.finalizeNonce(s(ae.nonce,c,r,e)),w=Qe(s(ae.challenge,u,r,e)),a=this.finalizeSig(f,h,w,n);return jt(a,e,r)||this.error(),a}}async function vn(t,e,n){return new Nt(t,e,n).calc()}function xn(t,e,n){return new Nt(t,e,n).calcSync()}function Zt(t,e,n){const r=t instanceof ke,o=r?t:ke.fromHex(t);return r&&o.assertValidity(),{...o,m:me(e),P:bn(n)}}function Gt(t,e,n,r){const o=$.BASE.multiplyAndAddUnsafe(e,De(n),d(-r,_.n));return!(!o||!o.hasEvenY()||o.x!==t)}async function Vt(t,e,n){try{const{r,s:o,m:s,P:c}=Zt(t,e,n),f=Qe(await Y.taggedHash(ae.challenge,He(r),c.toRawX(),s));return Gt(r,c,o,f)}catch{return!1}}function jt(t,e,n){try{const{r,s:o,m:s,P:c}=Zt(t,e,n),f=Qe(Y.taggedHashSync(ae.challenge,He(r),c.toRawX(),s));return Gt(r,c,o,f)}catch(r){if(r instanceof Ot)throw r;return!1}}const Ft={Signature:ke,getPublicKey:Sn,sign:vn,verify:Vt,signSync:xn,verifySync:jt};$.BASE._setWindowSize(8);const V={node:un,web:typeof self=="object"&&"crypto"in self?self.crypto:void 0},ae={challenge:"BIP0340/challenge",aux:"BIP0340/aux",nonce:"BIP0340/nonce"},Ge={},Y={bytesToHex:Ae,hexToBytes:ie,concatBytes:Te,mod:d,invert:tt,isValidPrivateKey(t){try{return De(t),!0}catch{return!1}},_bigintTo32Bytes:He,_normalizePrivateKey:De,hashToPrivateKey:t=>{t=me(t);const e=Re+8;if(t.length<e||t.length>1024)throw new Error("Expected valid bytes of private key as per FIPS 186");const n=d(X(t),_.n-R)+R;return He(n)},randomBytes:(t=32)=>{if(V.web)return V.web.getRandomValues(new Uint8Array(t));if(V.node){const{randomBytes:e}=V.node;return Uint8Array.from(e(t))}else throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>Y.hashToPrivateKey(Y.randomBytes(Re+8)),precompute(t=8,e=$.BASE){const n=e===$.BASE?e:new $(e.x,e.y);return n._setWindowSize(t),n.multiply(_e),n},sha256:async(...t)=>{if(V.web){const e=await V.web.subtle.digest("SHA-256",Te(...t));return new Uint8Array(e)}else if(V.node){const{createHash:e}=V.node,n=e("sha256");return t.forEach(r=>n.update(r)),Uint8Array.from(n.digest())}else throw new Error("The environment doesn't have sha256 function")},hmacSha256:async(t,...e)=>{if(V.web){const n=await V.web.subtle.importKey("raw",t,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),r=Te(...e),o=await V.web.subtle.sign("HMAC",n,r);return new Uint8Array(o)}else if(V.node){const{createHmac:n}=V.node,r=n("sha256",t);return e.forEach(o=>r.update(o)),Uint8Array.from(r.digest())}else throw new Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,taggedHash:async(t,...e)=>{let n=Ge[t];if(n===void 0){const r=await Y.sha256(Uint8Array.from(t,o=>o.charCodeAt(0)));n=Te(r,r),Ge[t]=n}return Y.sha256(n,...e)},taggedHashSync:(t,...e)=>{if(typeof xe!="function")throw new Ot("sha256Sync is undefined, you need to set it");let n=Ge[t];if(n===void 0){const r=xe(Uint8Array.from(t,o=>o.charCodeAt(0)));n=Te(r,r),Ge[t]=n}return xe(n,...e)},_JacobianPoint:A};Object.defineProperties(Y,{sha256Sync:{configurable:!1,get(){return xe},set(t){xe||(xe=t)}},hmacSha256Sync:{configurable:!1,get(){return st},set(t){st||(st=t)}}});const{floor:ft,random:An,sin:kn}=Math,Le="Trystero",Me=(t,e)=>Array(t).fill().map(e),Pt="0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz",lt=t=>Me(t,()=>Pt[ft(An()*Pt.length)]).join(""),Se=lt(20),he=Promise.all.bind(Promise),Tn=typeof window<"u",{entries:$t,fromEntries:Bn,keys:Pn}=Object,de=()=>{},oe=t=>new Error(`${Le}: ${t}`),$n=new TextEncoder,In=new TextDecoder,ye=t=>$n.encode(t),We=t=>In.decode(t),ut=t=>t.reduce((e,n)=>e+n.toString(16).padStart(2,"0"),""),Ve=(...t)=>t.join("@"),_n=(t,e)=>{const n=[...t],r=()=>{const s=kn(e++)*1e4;return s-ft(s)};let o=n.length;for(;o;){const s=ft(r()*o--);[n[o],n[s]]=[n[s],n[o]]}return n},Rn=(t,e,n,r)=>(t.relayUrls||(r?_n(e,Kt(t.appId)):e)).slice(0,t.relayUrls?t.relayUrls.length:t.relayRedundancy||n),se=JSON.stringify,et=JSON.parse,Kt=(t,e=Number.MAX_SAFE_INTEGER)=>t.split("").reduce((n,r)=>n+r.charCodeAt(0),0)%e,It=3333,be={},Cn=(t,e)=>{const n={},r=()=>{const o=new WebSocket(t);o.onclose=()=>{be[t]??(be[t]=It),setTimeout(r,be[t]),be[t]*=2},o.onmessage=s=>e(s.data),n.socket=o,n.url=o.url,n.ready=new Promise(s=>o.onopen=()=>{s(n),be[t]=It}),n.send=s=>{o.readyState===1&&o.send(s)}};return r(),n},dt="AES-GCM",at={},Hn=t=>btoa(String.fromCharCode.apply(null,new Uint8Array(t))),Un=t=>{const e=atob(t);return new Uint8Array(e.length).map((n,r)=>e.charCodeAt(r)).buffer},je=async t=>at[t]||(at[t]=Array.from(new Uint8Array(await crypto.subtle.digest("SHA-1",ye(t)))).map(e=>e.toString(36)).join("")),Dn=async(t,e,n)=>crypto.subtle.importKey("raw",await crypto.subtle.digest({name:"SHA-256"},ye(`${t}:${e}:${n}`)),{name:dt},!1,["encrypt","decrypt"]),Wt="$",Xt=",",Ln=async(t,e)=>{const n=crypto.getRandomValues(new Uint8Array(16));return n.join(Xt)+Wt+Hn(await crypto.subtle.encrypt({name:dt,iv:n},await t,ye(e)))},Mn=async(t,e)=>{const[n,r]=e.split(Wt);return We(await crypto.subtle.decrypt({name:dt,iv:new Uint8Array(n.split(Xt))},await t,Un(r)))},On=5e3,_t="icegatheringstatechange",Rt="offer",zn="answer",Ct=(t,{rtcConfig:e,rtcPolyfill:n,turnConfig:r})=>{const o=new(n||RTCPeerConnection)({iceServers:Nn.concat(r||[]),...e}),s={};let c=!1,f=!1,u=null;const h=a=>{a.binaryType="arraybuffer",a.bufferedAmountLowThreshold=65535,a.onmessage=l=>s.data?.(l.data),a.onopen=()=>s.connect?.(),a.onclose=()=>s.close?.(),a.onerror=l=>s.error?.(l)},w=a=>Promise.race([new Promise(l=>{const p=()=>{a.iceGatheringState==="complete"&&(a.removeEventListener(_t,p),l())};a.addEventListener(_t,p),p()}),new Promise(l=>setTimeout(l,On))]).then(()=>({type:a.localDescription.type,sdp:a.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g,"")}));return t?(u=o.createDataChannel("data"),h(u)):o.ondatachannel=({channel:a})=>{u=a,h(a)},o.onnegotiationneeded=async()=>{try{c=!0,await o.setLocalDescription();const a=await w(o);s.signal?.(a)}catch(a){s.error?.(a)}finally{c=!1}},o.onconnectionstatechange=()=>{["disconnected","failed","closed"].includes(o.connectionState)&&s.close?.()},o.ontrack=a=>{s.track?.(a.track,a.streams[0]),s.stream?.(a.streams[0])},o.onremovestream=a=>s.stream?.(a.stream),t&&(o.canTrickleIceCandidates||o.onnegotiationneeded()),{created:Date.now(),connection:o,get channel(){return u},get isDead(){return o.connectionState==="closed"},async signal(a){if(!(u?.readyState==="open"&&!a.sdp?.includes("a=rtpmap")))try{if(a.type===Rt){if(c||o.signalingState!=="stable"&&!f){if(t)return;await he([o.setLocalDescription({type:"rollback"}),o.setRemoteDescription(a)])}else await o.setRemoteDescription(a);await o.setLocalDescription();const l=await w(o);return s.signal?.(l),l}else if(a.type===zn){f=!0;try{await o.setRemoteDescription(a)}finally{f=!1}}}catch(l){s.error?.(l)}},sendData:a=>u.send(a),destroy:()=>{u?.close(),o.close(),c=!1,f=!1},setHandlers:a=>Object.assign(s,a),offerPromise:t?new Promise(a=>s.signal=l=>{l.type===Rt&&a(l)}):Promise.resolve(),addStream:a=>a.getTracks().forEach(l=>o.addTrack(l,a)),removeStream:a=>o.getSenders().filter(l=>a.getTracks().includes(l.track)).forEach(l=>o.removeTrack(l)),addTrack:(a,l)=>o.addTrack(a,l),removeTrack:a=>{const l=o.getSenders().find(p=>p.track===a);l&&o.removeTrack(l)},replaceTrack:(a,l)=>{const p=o.getSenders().find(T=>T.track===a);if(p)return p.replaceTrack(l)}}},Nn=[...Me(3,(t,e)=>`stun:stun${e||""}.l.google.com:19302`),"stun:stun.cloudflare.com:3478"].map(t=>({urls:t})),Zn=Object.getPrototypeOf(Uint8Array),Xe=12,qt=0,qe=qt+Xe,Ye=qe+1,$e=Ye+1,Ie=$e+1,ue=16*2**10-Ie,Fe=255,Ht="bufferedamountlow",Ee=t=>"@_"+t,Gn=(t,e,n)=>{const r={},o={},s={},c={},f={},u={},h={},w={onPeerJoin:de,onPeerLeave:de,onPeerStream:de,onPeerTrack:de},a=(i,y)=>(i?Array.isArray(i)?i:[i]:Pn(r)).flatMap(S=>{const v=r[S];return v?y(S,v):(console.warn(`${Le}: no peer with id ${S} found`),[])}),l=i=>{r[i]&&(r[i].destroy(),delete r[i],delete c[i],delete f[i],w.onPeerLeave(i),e(i))},p=i=>{if(o[i])return s[i];if(!i)throw oe("action type argument is required");const y=ye(i);if(y.byteLength>Xe)throw oe(`action type string "${i}" (${y.byteLength}b) exceeds byte limit (${Xe}). Hint: choose a shorter name.`);const S=new Uint8Array(Xe);S.set(y);let v=0;return o[i]={onComplete:de,onProgress:de,setOnComplete:g=>o[i]={...o[i],onComplete:g},setOnProgress:g=>o[i]={...o[i],onProgress:g},send:async(g,E,B,N)=>{if(B&&typeof B!="object")throw oe("action meta argument must be an object");const L=typeof g;if(L==="undefined")throw oe("action data cannot be undefined");const Q=L!=="string",P=g instanceof Blob,ee=P||g instanceof ArrayBuffer||g instanceof Zn;if(B&&!ee)throw oe("action meta argument can only be used with binary data");const O=ee?new Uint8Array(P?await g.arrayBuffer():g):ye(Q?se(g):g),K=B?ye(se(B)):null,H=Math.ceil(O.byteLength/ue)+(B?1:0)||1,U=Me(H,(M,D)=>{const te=D===H-1,le=B&&D===0,ne=new Uint8Array(Ie+(le?K.byteLength:te?O.byteLength-ue*(H-(B?2:1)):ue));return ne.set(S),ne.set([v],qe),ne.set([te|le<<1|ee<<2|Q<<3],Ye),ne.set([Math.round((D+1)/H*Fe)],$e),ne.set(B?le?K:O.subarray((D-1)*ue,D*ue):O.subarray(D*ue,(D+1)*ue),Ie),ne});return v=v+1&Fe,he(a(E,async(M,D)=>{const{channel:te}=D;let le=0;for(;le<H;){const ne=U[le];if(te.bufferedAmount>te.bufferedAmountLowThreshold&&await new Promise(nn=>{const gt=()=>{te.removeEventListener(Ht,gt),nn()};te.addEventListener(Ht,gt)}),!r[M])break;D.sendData(ne),le++,N?.(ne[$e]/Fe,M,B)}}))}},s[i]||(s[i]=[o[i].send,o[i].setOnComplete,o[i].setOnProgress])},T=(i,y)=>{var H,U;const S=new Uint8Array(y),v=We(S.subarray(qt,qe)).replaceAll("\0",""),[g]=S.subarray(qe,Ye),[E]=S.subarray(Ye,$e),[B]=S.subarray($e,Ie),N=S.subarray(Ie),L=!!(E&1),Q=!!(E&2),P=!!(E&4),ee=!!(E&8);if(!o[v]){console.warn(`${Le}: received message with unregistered type (${v})`);return}c[i]||(c[i]={}),(H=c[i])[v]||(H[v]={});const O=(U=c[i][v])[g]||(U[g]={chunks:[]});if(Q?O.meta=et(We(N)):O.chunks.push(N),o[v].onProgress(B/Fe,i,O.meta),!L)return;const K=new Uint8Array(O.chunks.reduce((M,D)=>M+D.byteLength,0));if(O.chunks.reduce((M,D)=>(K.set(D,M),M+D.byteLength),0),delete c[i][v][g],P)o[v].onComplete(K,i,O.meta);else{const M=We(K);o[v].onComplete(ee?et(M):M,i)}},C=async()=>{await Oe(""),await new Promise(i=>setTimeout(i,99)),$t(r).forEach(([i,y])=>{y.destroy(),delete r[i]}),n()},[z,F]=p(Ee("ping")),[Z,q]=p(Ee("pong")),[m,b]=p(Ee("signal")),[x,I]=p(Ee("stream")),[G,J]=p(Ee("track")),[Oe,nt]=p(Ee("leave"));return t((i,y)=>{r[y]||(r[y]=i,i.setHandlers({data:S=>T(y,S),stream:S=>{w.onPeerStream(S,y,u[y]),delete u[y]},track:(S,v)=>{w.onPeerTrack(S,v,y,h[y]),delete h[y]},signal:S=>m(S,y),close:()=>l(y),error:S=>{console.error(S),l(y)}}),w.onPeerJoin(y))}),F((i,y)=>Z("",y)),q((i,y)=>{f[y]?.(),delete f[y]}),b((i,y)=>r[y]?.signal(i)),I((i,y)=>u[y]=i),J((i,y)=>h[y]=i),nt((i,y)=>l(y)),Tn&&addEventListener("beforeunload",C),{makeAction:p,leave:C,ping:async i=>{if(!i)throw oe("ping() must be called with target peer ID");const y=Date.now();return z("",i),await new Promise(S=>f[i]=S),Date.now()-y},getPeers:()=>Bn($t(r).map(([i,y])=>[i,y.connection])),addStream:(i,y,S)=>a(y,async(v,g)=>{S&&await x(S,v),g.addStream(i)}),removeStream:(i,y)=>a(y,(S,v)=>v.removeStream(i)),addTrack:(i,y,S,v)=>a(S,async(g,E)=>{v&&await G(v,g),E.addTrack(i,y)}),removeTrack:(i,y)=>a(y,(S,v)=>v.removeTrack(i)),replaceTrack:(i,y,S,v)=>a(S,async(g,E)=>{v&&await G(v,g),E.replaceTrack(i,y)}),onPeerJoin:i=>w.onPeerJoin=i,onPeerLeave:i=>w.onPeerLeave=i,onPeerStream:i=>w.onPeerStream=i,onPeerTrack:i=>w.onPeerTrack=i}},Vn=20,jn=5333,Ut=57333,Fn=({init:t,subscribe:e,announce:n})=>{const r={};let o=!1,s,c,f;return(u,h,w)=>{const{appId:a}=u;if(r[a]?.[h])return r[a][h];const l={},p={},T=Ve(Le,a,h),C=je(T),z=je(Ve(T,Se)),F=Dn(u.password||"",a,h),Z=g=>async E=>({type:E.type,sdp:await g(F,E.sdp)}),q=Z(Mn),m=Z(Ln),b=()=>Ct(!0,u),x=(g,E,B)=>{if(p[E]){p[E]!==g&&g.destroy();return}p[E]=g,v(g,E),l[E]?.forEach((N,L)=>{L!==B&&N.destroy()}),delete l[E]},I=(g,E)=>{p[E]===g&&delete p[E]},G=(g,E)=>{if(p[g])return;const B=l[g]?.[E];B&&(delete l[g][E],B.destroy())},J=g=>(c.push(...Me(g,b)),he(c.splice(0,g).map(E=>E.offerPromise.then(m).then(B=>({peer:E,offer:B}))))),Oe=(g,E)=>w?.({error:`incorrect password (${u.password}) when decrypting ${E}`,appId:a,peerId:g,roomId:h}),nt=g=>async(E,B,N)=>{const[L,Q]=await he([C,z]);if(E!==L&&E!==Q)return;const{peerId:P,offer:ee,answer:O,peer:K}=typeof B=="string"?et(B):B;if(!(P===Se||p[P])){if(P&&!ee&&!O){if(l[P]?.[g])return;const[[{peer:H,offer:U}],M]=await he([J(1),je(Ve(T,P))]);l[P]||(l[P]=[]),l[P][g]=H,setTimeout(()=>G(P,g),i[g]*.9),H.setHandlers({connect:()=>x(H,P,g),close:()=>I(H,P)}),N(M,se({peerId:Se,offer:U}))}else if(ee){if(l[P]?.[g]&&Se>P)return;const U=Ct(!1,u);U.setHandlers({connect:()=>x(U,P,g),close:()=>I(U,P)});let M;try{M=await q(ee)}catch{Oe(P,"offer");return}if(U.isDead)return;const[D,te]=await he([je(Ve(T,P)),U.signal(M)]);N(D,se({peerId:Se,answer:await m(te)}))}else if(O){let H;try{H=await q(O)}catch{Oe(P,"answer");return}if(K)K.setHandlers({connect:()=>x(K,P,g),close:()=>I(K,P)}),K.signal(H);else{const U=l[P]?.[g];U&&!U.isDead&&U.signal(H)}}}};if(!u)throw oe("requires a config map as the first argument");if(!a&&!u.firebaseApp)throw oe("config map is missing appId field");if(!h)throw oe("roomId argument required");if(!o){const g=t(u);c=Me(Vn,b),s=Array.isArray(g)?g:[g],o=!0,f=setInterval(()=>c=c.filter(E=>{const B=Date.now()-E.created<Ut;return B||E.destroy(),B}),Ut*1.03)}const i=s.map(()=>jn),y=[],S=s.map(async(g,E)=>e(await g,await C,await z,nt(E),J));he([C,z]).then(([g,E])=>{const B=async(N,L)=>{const Q=await n(N,g,E);typeof Q=="number"&&(i[L]=Q),y[L]=setTimeout(()=>B(N,L),i[L])};S.forEach(async(N,L)=>{await N,B(await s[L],L)})});let v=de;return r[a]||(r[a]={}),r[a][h]=Gn(g=>v=g,g=>delete p[g],()=>{delete r[a][h],y.forEach(clearTimeout),S.forEach(async g=>(await g)()),clearInterval(f)})}},Kn=5,Yt="x",Jt="EVENT",Qt=Y.randomPrivateKey(),Wn=ut(Ft.getPublicKey(Qt)),ht={},Pe={},ct={},en=()=>Math.floor(Date.now()/1e3),tn=t=>ct[t]??(ct[t]=Kt(t,1e4)+2e4),Dt=async(t,e)=>{const n={kind:tn(t),content:e,pubkey:Wn,created_at:en(),tags:[[Yt,t]]},r=ut(new Uint8Array(await crypto.subtle.digest("SHA-256",ye(se([0,n.pubkey,n.created_at,n.kind,n.tags,n.content])))));return se([Jt,{...n,id:r,sig:ut(await Ft.sign(r,Qt))}])},Lt=(t,e)=>(ht[t]=e,se(["REQ",t,{kinds:[tn(e)],since:en(),["#"+Yt]:[e]}])),Mt=t=>(delete ht[t],se(["CLOSE",t])),Xn=Fn({init:t=>Rn(t,qn,Kn,!0).map(e=>{const n=Cn(e,r=>{const[o,s,c,f]=et(r);if(o!==Jt){const u=`${Le}: relay failure from ${n.url} - `;o==="NOTICE"?console.warn(u+s):o==="OK"&&!c&&console.warn(u+f);return}Pe[s]?.(ht[s],c.content)});return n.ready}),subscribe:(t,e,n,r)=>{const o=lt(64),s=lt(64);return Pe[o]=Pe[s]=(c,f)=>r(c,f,async(u,h)=>t.send(await Dt(u,h))),t.send(Lt(o,e)),t.send(Lt(s,n)),()=>{t.send(Mt(o)),t.send(Mt(s)),delete Pe[o],delete Pe[s]}},announce:async(t,e)=>t.send(await Dt(e,se({peerId:Se})))}),qn=["black.nostrcity.club","eu.purplerelay.com","ftp.halifax.rwth-aachen.de/nostr","nostr.cool110.xyz","nostr.data.haus","nostr.mom","nostr.oxtr.dev","nostr.sathoarder.com","nostr.vulpem.com","playground.nostrcheck.me/relay","relay.agorist.space","relay.binaryrobot.com","relay.fountain.fm","relay.mostro.network","relay.nostraddress.com","relay.nostrdice.com","relay.nostromo.social","relay.oldenburg.cool","relay.snort.social","relay.verified-nostr.com","yabu.me/v2"].map(t=>"wss://"+t);var Yn=j("<h1>Online"),Jn=j("<h2>Join a Room"),Qn=j('<div class=join-room-container><input type=text placeholder="Enter room ID"><input type=text placeholder="Enter room password (optional)"><button>Join Room'),er=j("<h2>Chat"),tr=j('<div class=send-message-container><input type=text placeholder="Type a message..."><button>Send'),nr=j("<div class=chat-container>"),rr=j("<div>Connected to room <!> <button>Leave Room"),or=j("<div>"),sr=j("<div>Waiting for peer..."),ar=j("<div>Peer: "),cr=j("<div>No messages yet"),ir=j("<div class=chat-message>[<!>] "),fr=j("<div>Loading game...");const lr="pacific.alvarado.dev",ur="temp",gr=()=>{let t,e,n;const[r,o]=an({roomId:null,password:null,room:null,peers:[],sendGameEvent:null,sendChat:null,chatMessages:[],gameConfig:null,randomDraw:Math.random()}),s=yt(()=>!!r.room&&r.peers.length>0),c=yt(()=>s()&&!!r.gameConfig),f=cn();mt(()=>{o("room",r.roomId?u({roomId:r.roomId,password:r.password??ur}):null),rn(()=>r.room?.leave())});function u({roomId:m,password:b}){const I=Xn({appId:lr,password:b},m,h);return w(I),I}function h(m){console.error("[useRoom] Error joining room:",m)}function w(m){m.onPeerJoin(a),m.onPeerLeave(l);const[b,x]=m.makeAction("gameEvent");o("sendGameEvent",()=>b),x(p);const[I,G]=m.makeAction("chatMessage");o("sendChat",()=>I),G(z)}function a(m){o("peers",r.peers.length,m);const b={eventType:"negotiation",draw:r.randomDraw};r.sendGameEvent?.(b).catch(x=>{console.error("[onPeerJoin]",x)})}function l(m){o("peers",b=>b.filter(x=>x!==m))}function p(m,b){console.log("[onGameEvent]",{data:m,peerId:b});const x=m;switch(x.eventType){case"negotiation":T(x);break;case"moveMade":C(x);break}}function T(m){r.gameConfig&&o("gameConfig",null),setTimeout(()=>{o("gameConfig",{player:m.draw<r.randomDraw?"blue":"red",turn:"blue"})},500)}function C(m){f.emit("moveMade",m)}function z(m,b){o("chatMessages",r.chatMessages.length,{content:m,senderId:b})}function F(){const m=t.value||null,b=e.value||null;on(()=>{o("roomId",m),o("password",b)})}function Z(){const m=n.value;!m||!r.sendChat||(o("chatMessages",r.chatMessages.length,{content:m,senderId:"self"}),r.sendChat(m).catch(b=>{console.error("[handleSendMessage]",b)}))}function q(){o("roomId",null)}return mt(()=>{r.peers.length>0&&console.log("[useEvent] Connected peers:",r.peers)}),[Yn(),we(ot,{get when(){return!r.room},get fallback(){return[(()=>{var m=rr(),b=m.firstChild,x=b.nextSibling,I=x.nextSibling,G=I.nextSibling;return pe(m,()=>r.roomId,x),G.$$click=q,m})(),(()=>{var m=or();return pe(m,we(wt,{get each(){return r.peers},get fallback(){return sr()},children:b=>(()=>{var x=ar();return x.firstChild,pe(x,b,null),x})()})),m})()]},get children(){return[Jn(),(()=>{var m=Qn(),b=m.firstChild,x=b.nextSibling,I=x.nextSibling,G=t;typeof G=="function"?rt(G,b):t=b;var J=e;return typeof J=="function"?rt(J,x):e=x,I.$$click=F,m})()]}}),we(ot,{get when(){return s()},get children(){return[er(),(()=>{var m=tr(),b=m.firstChild,x=b.nextSibling,I=n;return typeof I=="function"?rt(I,b):n=b,x.$$click=Z,m})(),(()=>{var m=nr();return pe(m,we(wt,{get each(){return r.chatMessages},get fallback(){return cr()},children:b=>{const x=b.senderId==="self";return(()=>{var I=ir(),G=I.firstChild,J=G.nextSibling;return J.nextSibling,I.classList.toggle("self",!!x),I.classList.toggle("peer",!x),pe(I,()=>b.senderId,J),pe(I,()=>b.content,null),I})()}})),m})(),we(ot,{get when(){return c()},get fallback(){return fr()},get children(){return we(fn,{get gameConfig(){return r.gameConfig},emitter:f})}})]}})]};sn(["click"]);export{gr as default};
